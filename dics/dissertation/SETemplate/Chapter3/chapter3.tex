\chapter{Implementation}

The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?

It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? 

You can conclude this section by reviewing the end of the implementation stage against the planned requirements.
\section{Location Based Help}
Throughout the design phase of the project the Help Activity is referred to as most likely to be the easiest feature to implement, when it came to implementation these assumptions were mostly correct.  Due to past work the developer was already aware of the Great Circle function, while research would have quickly led to the function itself it did save some time. 

There are a fair amount of changes to the implementation shown in the class diagram, some of this was done to simplify the process and stop code being used twice in two different places. The largest change is that the $calcDist$ function shown in the diagram has been pulled into its own class, this was done after initial development on the activity due to the route plotter also needing a function to calculate distance, it was best practice to only have the code exist once in the application.

Another change is the removal of the $loadHelpPoints$ function, while loading from a file is completed throughout the application in this case problems arose which made the process seem to be a waste of resources during this specific time line. While looking for information regarding people who could be contacted for help, little turned up. Details relating to three buildings were found so for the current iteration they are hard coded. 

A small change within the program is also what the $sortHelpPoints$ function returns, in the diagram it returns the sorted array. However in actuality it now returns the index of the closest location, this removes some stress on the device and is overall simpler yet still effective. A further small change is the removal of the $displayClosest$ function. In actuality this was not needed, all methods are called in the $onCreate$ due to the simple nature of the task, once the right index has been found what the method was meant to do just takes a single line of code so the inclusion of this method was seen as unnecessary.

The location based help function was actually simpler than initially thought, due to its very small size. A users location is easily found using the Location Manager and from there its basic object manipulation mostly. Implementing the great circle function took some time until a fitting one could be used, taken from Stack Overflow. Other proposed solutions seemed overly complex for what was considered, this was due to most of them including a height variable which was omitted in this case due to the small nature of campus. 

\subsection{Updating Help Location}
One idea that was experimented with was the idea of having the activity update when it moved into a new 'area' of help. This was done by repeated updating of the user location and rerunning of the methods which calculated the closest position. While it works in practice the major issue was what was seen as a good degree of uncertainty in the calculations.

While the Great Circle function works well, with its results being tested against measurements competed on Google Maps, reliability of the GPS co ordinates were not as certain. While co ordinates give us a very close estimate of our position, they are not always perfect. After some research it was clear that civilian GPS while in good conditions could return results within a metre, other factors that affect the accuracy are present on campus. Looking at figures, most GPS queries return accuracy to within 3.5 metres. However the impacting variables of receiver quality and signal blockage are not something we can plan for, due to these reasons a series of decisions were made.

As can be seen in the figure above, with the boundary between some buildings being so small, an error of 5 or so metres, something that has been seen, would provide false readings that would not be updated until the next cycle. Due to this the implemention of updating values on the Help page was omitted, the text displayed clearly displays the building the help is for, if this is wrong  a button to update values has been included.  

\section{Building Display}
During implementation a large amount of change was made to the way that the Building Display worked, a lot of this was down to it sharing an Activity with the Route Plotter. Initially this was done as the activities used similar resources and seemed small enough to not cause too many issues. However into development it was decided that the two activities really should have been separate, if nothing else than for clarities sake. However this was not decided until the features were complete, so as the project stands the screens have not been split. 
\subsection{Removal of Render functions}
In the program the largest change is the removal of the $renderPlotter$ and $renderDisplay$ functions. In past documentation these were said to be the methods that would actually render what was needed, however these have been removed and the problem handled in the $onCreate$. This is done by the press of either the Building Display Button or the Route Plotter button initially sending through a string which represents the users desire. From there the $onCreate$ is split, if the user has said they want to plot a route then a different part of the method is entered, in both cases the visibility of a set of buttons and other interactive elements is set. By doing this we can view the activity as having two $onCreate$ methods, its just that they are nested within the same parent method. 
\subsection{Other Changes}
A change seen previously is the removal of the $calcDistance$ function from this class as well, it now relies on the class that handles all of the distance algorithms. A similar change is the removal of the $loadPlaces$ function. Loading of places is handled by the actual Place class, called locations, in the application. By being moved away we keep the code in this class purely related to the displaying of locations, removing any blur between the classes. $showByType$ is implemented in the suggested way by the class diagram, it is called using the $setOnClickListener$ functions used in the $onCreate$ function. These listeners set the behaviours for an interactive element in the design, in this case the $showByType$ function is called with the buttons type being passed in as the string variable. For showing Lecture Buildings the String Lecture is passed in and the array searched for any location that matches that information. $showByType$ was actually initially implemented all in each $onClickListener$, while no real problem for the user it meant the method was implemented for however many types of building there were. When the design was finally adhered to it vastly simplified the process and created a much better class in terms of code quality. This also means that in the future any addition to the type of buildings will only need a few lines of code instead of the repeated fifteen or so which were initially being used. 

Throughout development other applications and documentation were reviewed which showed the use of custom markers for buildings, due to this the feature was also included within the application. With it only taking a small time and the result being a more customised application it was seen as a good time to improvement ratio. 

\section{Route Plotter}
Route plotting was an area in the application where a fair amount of issues arose during implementation, while the feature was successful many hard decision had to be made along the way and the result of those will have to be tested. With once again using GPS co ordinates for the positioning, problems arose with accuracy and exactly how a user would want to plot a route. Most of the class diagram relating to this feature is correct, the only difference is the movement of the log point method into the $onClickListener$.
\subsection{Plotting of points}
Plotting of points is an area which had similar issues to the updating of values in the Location Based Help feature. Mainly the testing of automatic point logging, this turned out to be a much bigger problem than in the help section. With the error in gps co ordinates sometimes being over 3 metres the automatic logging of points is not something which could be trusted to return viable results. Tests using automatic logging returned results, which when visualized, returned results similar to below. Any stop in a users movement would cause problems as any change GPS made then would cause a small difference meaning that it looked like the user was taking an erratic route.

As can be seen from the pictures above this was not an ideal way to implement the feature, what is now done is a point is only added when a user asks for it to be logged. Having the feature implemented this way means the user is free to explore paths, yet not plot them. Providing what is seen as a more user friendly experience. Another benefit found was that by using the Google Maps $locationListenerEnabled$ the user would be able to see their position, however the benefit goes further than that, in locations with good signal the point is plotted exactly at the displayed position. It is thought the reasoning is that both Google Maps and $logPoint$ method are both using a Location Manager which will always return the same results to both as its running on the same device.
\subsection{Visualizing and Cancelling}
Visualizing a route was implemented in the way detailed throughout the application, poly lines are drawn between each consecutive point causing a route which displays the users position throughout. Within the application every time a point is logged, except for the first time, the $paintRoute$ function is called, it takes the latest and previous logged point and simply paints a line between the two.

An implemented method which was not expected to be within the class is the $showDialog$ method, this is run when the user wants to cancel a walk. Absence of this method in the class diagram and other specifications is due to what was a lack of research on the possibility of a dialog box. It was wrongly assumed that the displaying of one would be smaller than it actually is, however the method is fairly simple. On the user wanting to cancel a walk, all points are wiped and the map cleared, on choosing no nothing is done. A further decision made here was whether to return the user to the data entry screen to reset the walk, however it is has been currently decided that a user cancelling a walk is more likely to be due to an error than anything else. Due to this route information is persistent unless the user chooses to go backwards to the data entry screen. 

\subsection{File Saving}
Saving the plotted route to a file was a task which took much longer than expected, this was due to a misread of the documentation. Through research it was found that an Android device typically has two types of storage, internal and external. It was assumed that external storage would only be possible with an SD card in the device, this was the first mistake which caused the long delay. A second compounding error was the assumption that saving to the internal memory would make the file accessible by the user, something which is only possible in cases where a device is rooted. These compounding factors caused the process to take a length of time which simply was not expected and set the development off by around two working days. 

During this time it was assumed that the file was simply not being created, however in actuality it was, it was just not available through any file browser, only through the application itself. This was due to the assumption that internal memory was accessible by anyone at any time, in reality files saved by applications to internal memory are only available to that application. Due to this, looking through the file system for the relevant folder was of no use, it was there but hidden. To combat this various techniques were researched of saving files without having to rely on an SD card as not all users would have them. 

One possible method was has been mentioned before was the uploading of a route so the user could retrieve it from any web connected device. Legacy code from previous projects was used to send of a JSON that included all of the relevant file information, using the LogCat feature in the Android Studio IDE showed that the data was being sent out, so the development could continue.

However, with further reference to some Stack Overflow answers to relevant questions, it was discovered that external memory is a fairly inaccurate name for what the memory actually is. In reality external memory represent one of two things, that an SD card is present or the device in question has inbuilt memory to store files. With this discovery the viablity of storing files locally vastly improved. As most devices are present with one or the other the final decision was that saving to external memory was the solution. With Google themselves trying to set the trend of removing the necessity of SD cards in Android devices it should be a smart decision for the future as well. 

\subsection{Writing to File}
Implementing this feature was simple once the problem of saving a file and accessing it were resolved. This functionality is provided by the $printFile$ method. This method takes the Route object and uses its variables to print a file that represents the route plotted. It is printed in such a way that it is compatible with the route finding side of the project. 

Printing the file is done with an $outputStreamWriter$ which takes a String and prints it into the file, each time a $write$ is called the writer uses a new line. Formatting for the file is as follows
$Start$\\
$Destination$\\
$Grading$\\
$Number of Points$\\
$Points$\\
$Destination$\\
$Grading$\\
$Number of Points$\\
$Points$\\
The format was dictated during the development of the route finder, having the file formatted as such allows for an easy implementation of a file reader. With the first 4 lines being static throughout files and the next being decided by the fourth line the code is easy to implement. From there we can see that another destination is listed, the above file contains details a Node which connects to two others and the path between them. 

Once the file is saved it is up to the user what they wish to do with it, this could range from testing of a path to full implementation to the graph. While a printed file links a Node into the graph changes still need to be made to detail the path to the Node for the user of other Nodes. This means changes need to be made to at least one other Nodes file for the Node to be fully linked. While this is not ideal there are very few ways around it, one possible way considered was to also create another file for the place the path connects to, which would contain the new path. However if multiple new paths were implemented at once, each time the new file for the Node would differ, addition by hand is not ideal but at least lets the user keep track of which files need what adding to them. 

\section{Route Plotting}
Route plotting was the key area of the application, this was due to the poor implementation of it in the original Access Aber. With so much feedback from the original version it was easy to set out a set of guidelines, some of which have been mentioned in the previous Design Specification. To begin with in the implementation a set of guidelines were set out which, if met, would cause the feature to be seen as a success for the current time line. 

\begin{itemize}
	\item 1 - Adapt the Route selector to be two selectors, a start and destination, rather than one which contains all possible routes.
	\item 2 - Implement an extendible graph that represents the campus and building locations.
	\item 3 - Have the route display gradings for the route, if the route is in segments display each segment in its respective colour.
	\item 4 - Give the user the opportunity to take a route with no steps, ideally this would be done on the same graph as standard route finding if possible.
	\item 5 - Display basic information about the route, stairs and distance ideally.  
\end{itemize}

These four criteria were seen as fairly reasonable targets, with the only worrying task being the no step feature, something which was known would be difficult. Item 5 was seen as a stretch goal as it would require the editing of the file format and as such a fairly large amount of code from some small prototypes and the route plotter.

Initial development time was used to implement the route object, something fairly simple. As an object itself the Route contains the information relating to its start, destination and the points along the route. This means it contains an Array List of what are called locations in the application, labelled places on the class diagram. This implementation, though simple, provides us with all of the information needed to find a path through the graph. When a Node is analysed, what is really happening is that a file is being loaded in which creates a set of routes, each are checked for where they end. If the route ends at the right place the solution is found, if not its end place is added as a Node to be searched next. 

Paths between nodes are stored as a set of locations, this is an object used repeatedly throughout the application, a 'locations' object contains a range of information, most importantly the co ordinates of the point. For route finding the rest of the information possible is irrelevant, other variables are used elsewhere. Having this one object which describes a location was a real benefit during development, it saved creating classes for what were meant to be different types of location like buildings. Due to this locations can have names and descriptions, it is just that they are not important for route finding. 
