\chapter{Implementation}

The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?

It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? 

You can conclude this section by reviewing the end of the implementation stage against the planned requirements.
\section{Location Based Help}
Throughout the design phase of the project the Help Activity is referred to as most likely to be the easiest feature to implement, when it came to implementation these assumptions were mostly correct.  Due to past work the developer was already aware of the Great Circle function, while research would have quickly led to the function itself it did save some time. 

There are a fair amount of changes to the implementation shown in the class diagram, some of this was done to simplify the process and stop code being used twice in two different places. The largest change is that the $calcDist$ function shown in the diagram has been pulled into its own class, this was done after initial development on the activity due to the route plotter also need a function to calculate distance and it made sense to only have the code exist once in the application.

Another change is the removal of the $loadHelpPoints$ function, while loading from a file is completed throughout the application in this case problems arose which made the process seem to be a waste of resources during this specific time line. While looking for information regarding to people who could be contacted for help, little turned up. Details relating to three buildings were found so for the current iteration they are hard coded. 

A small change within the program is also what the $sortHelpPoints$ function returns, in the diagram it returns the sorted array. However in actuality it now returns the index of the closest location, this removes some stress on the device and is overall simple but effective. A further small change is the removal of the $displayClosest$ function. In actuality this was not needed, all methods are called in the $onCreate$ due to the simple nature of the task, once the right index has been found what the method was meant to do just takes a single line of code so the inclusion of this method was seen as unnecessary.

The location based help function was actually simpler than initially thought, due to its very small size. A users location is easily found using the Location Manager and from there its basic object manipulation mostly. Implementing the great circle function took some time until a fitting one could be used, taken from Stack Overflow. Other proposed solutions seemed overly complex for what was considered, this was due to most of them including a height variable which was omitted in this case due to the small nature of campus. 

\section{Building Display}
During implementation a large amount of change was made to the way that the Building Display worked, a lot of this was down to it sharing an Activity with the Route Plotter. Initially this was done as the activities used similar resources and seemed small enough to not cause too many issues. However into development it was decided that the two activities really should have been separate, if nothing else than for clarities sake. However this was not decided until the features were complete, so as the project stands the screens have not been split. 

In the program the largest change is the removal of the $renderPlotter$ and $renderDisplay$ functions. In past documentation these were said to be the methods that would actually render what was needed, however these have been removed and the problem handled in the $onCreate$. This is done by the press of either the Building Display Button or the Route Plotter button initially sending through a string which represents the users desire. From there the $onCreate$ is split, if the user has said they want to plot a route then a different part of the method is entered, in both cases the visibility of a set of buttons and other interactive elements is set. By doing this we can view the activity as having two $onCreate$ methods, its just that they are nested within the same parent method. 

A change seen previously is the removal of the $calcDistance$ function from this class as well, it now relies on the class that handles all of the distance algorithms. A similar change is the removal of the $loadPlaces$ function. Loading of places is handled by the actual Place class, called locations, in the application. By being moved away we keep the code in this class purely related to the displaying of locations, removing any blur between the classes. $showByType$ is implemented in the suggested way by the class diagram, it is called using the $setOnClickListener$ functions used in the $onCreate$ function. These listeners set the behaviours for an interactive element in the design, in this case the $showByType$ function is called with the buttons type being passed in as the string variable. For showing Lecture Buildings the String Lecture is passed in and the array searched for any location that matches that information. $showByType$ was actually initially implemented all in each $onClickListener$, while no real problem for the user it meant the method was implemented for however many types of building there were. When the design was finally adhered to it vastly simplified the process and created a much better class in terms of code quality. This also means that in the future any addition to the type of buildings will only need a few lines of code instead of the repeated fifteen or so which were initially being used. 